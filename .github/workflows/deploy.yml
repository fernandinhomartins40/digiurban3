name: üöÄ Deploy DigiUrban2 - DEPLOY LIMPO (Docker)

# Controle de concorr√™ncia - √öNICO deploy por vez
concurrency:
  group: digiurban2-production-deploy
  cancel-in-progress: true

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  VPS_HOST: '72.60.10.108'
  VPS_USER: 'root'
  APP_DIR: '/root/digiurban2'
  APP_PORT: '3002'
  IMAGE_NAME: 'digiurban2-gestao-urbana'
  CONTAINER_NAME: 'digiurban2-container'
  DOMAIN: 'digiurban.com.br'
  NGINX_CONTAINER: 'nginx-proxy'

jobs:
  analyze-changes:
    name: üîç Analisar Mudan√ßas
    runs-on: ubuntu-latest
    outputs:
      has_code_changes: ${{ steps.changes.outputs.has_code_changes }}
      has_package_changes: ${{ steps.changes.outputs.has_package_changes }}
      has_config_changes: ${{ steps.changes.outputs.has_config_changes }}
      needs_restart: ${{ steps.changes.outputs.needs_restart }}
      deploy_type: ${{ steps.changes.outputs.deploy_type }}
    
    steps:
    - name: üì• Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 2
    
    - name: üîç Analisar arquivos alterados
      id: changes
      run: |
        echo "üîç Analisando mudan√ßas desde o √∫ltimo commit..."
        
        # Obter arquivos alterados
        CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "all")
        echo "üìÅ Arquivos alterados:"
        echo "$CHANGED_FILES"
        
        # Inicializar flags
        HAS_CODE=false
        HAS_PACKAGE=false
        HAS_CONFIG=false
        NEEDS_RESTART=false
        
        # Analisar tipos de mudan√ßas para DigiUrban2 React App e Super Painel
        if echo "$CHANGED_FILES" | grep -E "(src/|super-admin/|database-setup/|vite\.config|index\.html|Dockerfile|nginx\.conf|\.env)" > /dev/null || [ "$CHANGED_FILES" = "all" ]; then
          HAS_CODE=true
          echo "‚úÖ Mudan√ßas de c√≥digo frontend/super-admin/database detectadas"
        fi
        
        if echo "$CHANGED_FILES" | grep -E "(package(-lock)?\.json|super-admin/package\.json)" > /dev/null; then
          HAS_PACKAGE=true
          echo "üì¶ Mudan√ßas em depend√™ncias detectadas"
        fi
        
        if echo "$CHANGED_FILES" | grep -E "(\.env|vite\.config\.(js|ts)|tailwind\.config\.(js|ts)|Dockerfile|\.dockerignore|nginx\.conf)" > /dev/null; then
          HAS_CONFIG=true
          echo "‚öôÔ∏è Mudan√ßas de configura√ß√£o detectadas"
        fi
        
        # Determinar se precisa restart
        if [[ "$HAS_CODE" == "true" || "$HAS_CONFIG" == "true" ]]; then
          NEEDS_RESTART=true
        fi
        
        # Determinar tipo de deploy
        if [[ "$HAS_PACKAGE" == "true" ]]; then
          DEPLOY_TYPE="full"
          echo "üîÑ Deploy completo necess√°rio (depend√™ncias mudaram)"
        elif [[ "$HAS_CODE" == "true" ]]; then
          DEPLOY_TYPE="code-only"
          echo "üìù Deploy apenas de c√≥digo"
        elif [[ "$HAS_CONFIG" == "true" ]]; then
          DEPLOY_TYPE="config-only"
          echo "‚öôÔ∏è Deploy apenas de configura√ß√£o"
        else
          DEPLOY_TYPE="minimal"
          echo "üìã Deploy m√≠nimo (docs/workflows)"
        fi
        
        # Definir outputs
        echo "has_code_changes=$HAS_CODE" >> $GITHUB_OUTPUT
        echo "has_package_changes=$HAS_PACKAGE" >> $GITHUB_OUTPUT
        echo "has_config_changes=$HAS_CONFIG" >> $GITHUB_OUTPUT
        echo "needs_restart=$NEEDS_RESTART" >> $GITHUB_OUTPUT
        echo "deploy_type=$DEPLOY_TYPE" >> $GITHUB_OUTPUT

  deploy:
    name: üöÄ Deploy Docker
    runs-on: ubuntu-latest
    needs: analyze-changes
    timeout-minutes: 45
    
    steps:
    - name: üìã Info do Deploy Docker
      run: |
        echo "üöÄ Deploy DigiUrban2 React App com Docker"
        echo "=============================================="
        echo "Commit: ${{ github.sha }}"
        echo "Branch: ${{ github.ref_name }}"
        echo "Tipo de Deploy: ${{ needs.analyze-changes.outputs.deploy_type }}"
        echo "Mudan√ßas de C√≥digo: ${{ needs.analyze-changes.outputs.has_code_changes }}"
        echo "Mudan√ßas de Depend√™ncias: ${{ needs.analyze-changes.outputs.has_package_changes }}"
        echo "Precisa Restart: ${{ needs.analyze-changes.outputs.needs_restart }}"
        echo "=============================================="

    - name: üîë Configurar SSH
      run: |
        echo "üîë Configurando SSH para deploy..."
        
        # Instalar sshpass para autentica√ß√£o por senha
        sudo apt-get update -qq
        sudo apt-get install -y sshpass
        
        # Configurar SSH com otimiza√ß√µes para conex√µes longas
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        # Configurar SSH client com keepalive
        cat > ~/.ssh/config << 'EOL'
        Host *
          ServerAliveInterval 60
          ServerAliveCountMax 120
          TCPKeepAlive yes
          ControlMaster auto
          ControlPath ~/.ssh/control-%h-%p-%r
          ControlPersist 600
          ConnectTimeout 30
        EOL
        chmod 600 ~/.ssh/config
        
        # Adicionar host conhecido para evitar prompt de verifica√ß√£o
        ssh-keyscan -H ${{ env.VPS_HOST }} >> ~/.ssh/known_hosts 2>/dev/null
        
        # Testar conex√£o SSH com senha e keepalive
        echo "üîç Testando conex√£o SSH com configura√ß√µes otimizadas..."
        if sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o ConnectTimeout=30 -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "echo 'Conex√£o SSH bem-sucedida'"; then
          echo "‚úÖ SSH configurado e testado com sucesso"
        else
          echo "‚ùå Falha na conex√£o SSH. Verifique se:"
          echo "  1. A secret VPS_PASSWORD cont√©m a senha correta"
          echo "  2. O servidor ${{ env.VPS_HOST }} est√° acess√≠vel"
          echo "  3. O usu√°rio ${{ env.VPS_USER }} existe e aceita autentica√ß√£o por senha"
          exit 1
        fi

    - name: üîç Verificar e instalar Docker na VPS
      run: |
        echo "üîç Verificando e instalando Docker se necess√°rio..."
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          echo '=== Verificando Docker na VPS ==='
          
          # Verificar se Docker est√° instalado
          if ! command -v docker &> /dev/null; then
            echo 'üì¶ Docker n√£o encontrado, instalando...'
            
            # Atualizar sistema
            apt-get update -y
            
            # Instalar depend√™ncias
            apt-get install -y apt-transport-https ca-certificates curl gnupg lsb-release
            
            # Adicionar chave GPG do Docker
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
            
            # Adicionar reposit√≥rio Docker
            echo \"deb [arch=\$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \$(lsb_release -cs) stable\" | tee /etc/apt/sources.list.d/docker.list > /dev/null
            
            # Instalar Docker
            apt-get update -y
            apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
            
            # Iniciar Docker
            systemctl start docker
            systemctl enable docker
            
            echo '‚úÖ Docker instalado com sucesso'
          else
            echo '‚úÖ Docker j√° est√° instalado'
          fi
          
          # Verificar vers√£o do Docker
          echo 'Docker version:'
          docker --version
          
          echo ''
          echo 'Docker service status:'
          systemctl is-active docker || systemctl start docker
          
          echo ''
          echo 'Docker Containers atuais:'
          docker ps --format 'table {{.Names}}\t{{.Status}}' | grep ${{ env.CONTAINER_NAME }} || echo 'Container n√£o rodando'
          
          echo ''
          echo 'Configura√ß√£o de Firewall/Porta 3002:'
          # Verificar se a porta 3002 est√° sendo usada
          netstat -tulpn | grep :3002 || echo 'Porta 3002 livre'
          
          # Verificar se iptables est√° bloqueando a porta 3002
          iptables -L INPUT -n | grep 3002 || echo 'Nenhuma regra espec√≠fica para porta 3002'
          
          echo ''
          echo '√öltima atualiza√ß√£o:'
          cd ${{ env.APP_DIR }} && git log --oneline -1 2>/dev/null || echo 'Reposit√≥rio n√£o inicializado'
        "

    - name: üì• Checkout do c√≥digo
      uses: actions/checkout@v4
    
    - name: üóÇÔ∏è Setup Node.js com cache
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        cache-dependency-path: package-lock.json

    - name: üì¶ Transferir c√≥digo para VPS
      run: |
        echo "üì¶ Transferindo c√≥digo para VPS via rsync..."
        
        # Instalar rsync
        sudo apt-get update -qq
        sudo apt-get install -y rsync
        
        # Log detalhado da conectividade
        echo "üîç Verificando conectividade SSH antes da transfer√™ncia..."
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no -v ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          echo 'Conectividade SSH confirmada'
          free -h
          df -h /
          docker --version
        " 2>&1 | head -20
        
        # Limpar diret√≥rio remoto
        echo "üßπ Limpando diret√≥rio remoto..."
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          rm -rf ${{ env.APP_DIR }}
          mkdir -p ${{ env.APP_DIR }}
          echo 'Diret√≥rio limpo e recriado'
        "
        
        # Transferir c√≥digo usando rsync com logs detalhados
        echo "üöÄ Iniciando transfer√™ncia rsync..."
        sshpass -p "${{ secrets.VPS_PASSWORD }}" rsync -avz --delete --progress \
          --exclude='.git/' \
          --exclude='node_modules/' \
          --exclude='.claude/' \
          --exclude='*.log' \
          --exclude='*.tmp' \
          --exclude='.DS_Store' \
          -e "ssh -o StrictHostKeyChecking=no -o ServerAliveInterval=60" \
          ./ ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:${{ env.APP_DIR }}/
        
        # Verificar transfer√™ncia com logs detalhados
        echo "‚úÖ Verificando transfer√™ncia..."
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          cd ${{ env.APP_DIR }}
          
          echo 'üìä Status da transfer√™ncia:'
          echo '  - Diret√≥rio atual:' \$(pwd)
          echo '  - Espa√ßo em disco:' \$(df -h . | tail -1)
          echo '  - Total de arquivos:' \$(find . -type f | wc -l)
          
          if [ -f Dockerfile ]; then
            echo '‚úÖ C√≥digo transferido com sucesso'
            echo 'üìÇ Arquivos principais:'
            ls -la | grep -E '(Dockerfile|package\.json|src|\.env|nginx\.conf)' || echo 'Verificando...'
            echo 'üìÇ Tamanho do package.json:' \$(wc -l package.json 2>/dev/null || echo 'N/A')
          else
            echo '‚ùå ERRO: Dockerfile n√£o encontrado!'
            echo 'üìÇ Conte√∫do atual do diret√≥rio:'
            ls -la
            echo 'üìÇ Estrutura de diret√≥rios:'
            find . -maxdepth 2 -type d
            exit 1
          fi
        "

    - name: üöÄ Deploy usando Docker
      run: |
        echo "üöÄ Executando deploy com Docker..."
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          cd ${{ env.APP_DIR }}
          
          # Deploy DigiUrban2 React App usando Docker
          echo 'üöÄ Executando deploy DigiUrban2 React App com Docker...'
          
          # Parar e remover container anterior se existir
          echo 'üîÑ Parando container anterior...'
          docker stop ${{ env.CONTAINER_NAME }} 2>/dev/null || true
          docker rm ${{ env.CONTAINER_NAME }} 2>/dev/null || true
          
          # Verificar processos Docker ativos (sem matar)
          echo 'üíÄ Verificando processos Docker...'
          if pgrep -f 'docker build' >/dev/null 2>&1; then
            echo '  ‚ö†Ô∏è Processos docker build encontrados (continuando)'
          fi
          if pgrep -f 'npm ci' >/dev/null 2>&1; then
            echo '  ‚ö†Ô∏è Processos npm ci encontrados (continuando)'
          fi
          echo '  ‚úÖ Verifica√ß√£o conclu√≠da'
          
          # Limpeza Docker simplificada
          echo 'üßπ Limpando recursos Docker...'
          
          # Verificar se Docker est√° funcionando
          if ! docker --version >/dev/null 2>&1; then
            echo '‚ùå Docker n√£o encontrado!'
            exit 1
          fi
          
          # Verificar se o servi√ßo Docker est√° rodando
          if ! systemctl is-active --quiet docker; then
            echo 'üîÑ Iniciando servi√ßo Docker...'
            systemctl start docker
            sleep 5
          fi
          
          # Teste b√°sico do Docker
          if ! docker info >/dev/null 2>&1; then
            echo '‚ùå Docker n√£o est√° funcionando corretamente!'
            systemctl status docker
            exit 1
          fi
          
          echo '‚úÖ Docker est√° funcionando corretamente'
          
          # Limpeza b√°sica e segura
          echo '  - Removendo imagem anterior se existir...'
          docker rmi ${{ env.IMAGE_NAME }}:latest 2>/dev/null || echo '    (nenhuma imagem para remover)'
          
          echo '  - Limpeza r√°pida de recursos n√£o utilizados...'
          docker system prune -f 2>/dev/null || echo '    (falha na limpeza, continuando)'
          
          echo '  ‚úÖ Limpeza conclu√≠da'
          
          # Build da imagem Docker com retry autom√°tico
          echo 'üèóÔ∏è Building Docker image com retry autom√°tico...'
          
          # Fun√ß√£o de retry para docker build
          build_with_retry() {
            local max_attempts=3
            local attempt=1
            local timeout_duration=1800  # 30 minutos
            
            while [ \$attempt -le \$max_attempts ]; do
              echo \"üîÑ Tentativa \$attempt/\$max_attempts do Docker build...\"
              
              # Usar timeout e network host para evitar builds infinitos
              if timeout \$timeout_duration docker build --network=host --no-cache --pull -t ${{ env.IMAGE_NAME }}:latest .; then
                echo \"‚úÖ Docker build bem-sucedido na tentativa \$attempt\"
                return 0
              else
                local exit_code=\$?
                echo \"‚ùå Docker build falhou na tentativa \$attempt (exit code: \$exit_code)\"
                
                if [ \$attempt -eq \$max_attempts ]; then
                  echo \"üí• Todas as tentativas de build falharam\"
                  return \$exit_code
                fi
                
                # Limpar containers e imagens √≥rf√£s antes de retry
                echo \"üßπ Limpando recursos Docker antes do retry...\"
                docker system prune -f --volumes 2>/dev/null || true
                docker builder prune -f 2>/dev/null || true
                
                # Aguardar antes do pr√≥ximo retry
                local wait_time=\$((attempt * 30))
                echo \"‚è≥ Aguardando \$wait_time segundos antes do pr√≥ximo retry...\"
                sleep \$wait_time
              fi
              
              attempt=\$((attempt + 1))
            done
          }
          
          # Executar build com retry
          build_with_retry
          
          # Verificar se a imagem foi criada
          if ! docker images | grep -q ${{ env.IMAGE_NAME }}; then
            echo '‚ùå Falha ao criar imagem Docker!'
            exit 1
          fi
          
          echo '‚úÖ Imagem Docker criada com sucesso'
          
          # Iniciar container na porta 3002 (VPS exclusiva)
          echo 'üöÄ Iniciando container na porta ${{ env.APP_PORT }}...'
          docker run -d \
            --name ${{ env.CONTAINER_NAME }} \
            -p ${{ env.APP_PORT }}:80 \
            --restart unless-stopped \
            --memory=1g \
            --cpus=2 \
            --tmpfs /tmp \
            --tmpfs /var/cache/nginx \
            --tmpfs /var/run \
            -e NODE_ENV=production \
            ${{ env.IMAGE_NAME }}:latest
          
          # Aguardar container inicializar
          echo '‚è≥ Aguardando container inicializar...'
          sleep 15
          
          # Verificar se container est√° rodando
          if ! docker ps | grep -q ${{ env.CONTAINER_NAME }}; then
            echo '‚ùå Container n√£o est√° rodando!'
            echo 'üìã Status do container:'
            docker ps -a | grep ${{ env.CONTAINER_NAME }} || echo 'Container n√£o encontrado'
            echo 'üìã Logs do container:'
            docker logs ${{ env.CONTAINER_NAME }} 2>/dev/null || echo 'Sem logs dispon√≠veis'
            exit 1
          fi
          
          # Verificar se est√° funcionando
          echo 'üîç Testando React app...'
          for i in {1..5}; do
            if curl -f -s http://localhost:${{ env.APP_PORT }}/ >/dev/null 2>&1; then
              echo '‚úÖ React app funcionando!'
              break
            else
              echo \"‚è≥ Tentativa \$i/5...\"
              sleep 5
            fi
            
            if [ \$i -eq 5 ]; then
              echo '‚ùå React app n√£o respondeu ap√≥s 5 tentativas'
              echo 'üìã Logs do container:'
              docker logs ${{ env.CONTAINER_NAME }}
              exit 1
            fi
          done
          
          echo '‚úÖ DigiUrban2 React App deployed successfully on port ${{ env.APP_PORT }}'
          echo 'üìä Status do container:'
          docker ps | grep ${{ env.CONTAINER_NAME }}
          echo '‚úÖ Deploy containerizado conclu√≠do'
        "

    - name: üåê Configurar Nginx para Landing Page
      run: |
        echo "üåê Configurando Nginx para servir landing page React..."
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          cd ${{ env.APP_DIR }}
          
          # Executar script de atualiza√ß√£o do Nginx para digiurban.com.br
          echo 'üîß Executando script de configura√ß√£o do Nginx para landing page...'
          chmod +x update-nginx-config.sh
          ./update-nginx-config.sh
          
          # Executar script de corre√ß√£o de CORS para apidigiruban.com.br
          echo 'üîß Corrigindo configura√ß√£o CORS para apidigiruban.com.br...'
          chmod +x fix-apidigiruban-cors.sh
          ./fix-apidigiruban-cors.sh
          
          echo '‚úÖ Configura√ß√£o do Nginx conclu√≠da'
        "

    - name: üîç Verifica√ß√£o Final
      run: |
        echo "üîç Verifica√ß√£o final..."
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          cd ${{ env.APP_DIR }}
          
          # Verificar status do container
          echo 'üîç Status do container:'
          if docker ps | grep -q ${{ env.CONTAINER_NAME }}; then
            echo '‚úÖ Container rodando'
            docker ps | grep ${{ env.CONTAINER_NAME }}
          else
            echo '‚ùå Container n√£o encontrado'
            exit 1
          fi
          
          # Verificar health check da aplica√ß√£o React (localhost)
          echo 'üîç Testando aplica√ß√£o React (localhost)...'
          if curl -f -s http://localhost:${{ env.APP_PORT }}/ >/dev/null 2>&1; then
            echo '‚úÖ Aplica√ß√£o React respondendo no localhost:${{ env.APP_PORT }}'
          else
            echo '‚ùå Aplica√ß√£o React n√£o est√° respondendo no localhost'
            docker logs ${{ env.CONTAINER_NAME }} --tail 10
            exit 1
          fi
          
          # Verificar health check via Nginx (dom√≠nio) - se configurado
          echo 'üîç Testando conectividade do dom√≠nio ${{ env.DOMAIN }}...'
          
          # Testar se o dom√≠nio responde (HTTP ou HTTPS)
          if curl -f -s -I http://${{ env.DOMAIN }}/ >/dev/null 2>&1; then
            echo '‚úÖ Dom√≠nio ${{ env.DOMAIN }} respondendo via HTTP'
            
            # Verificar se h√° redirecionamento para HTTPS
            if curl -f -s -I http://${{ env.DOMAIN }}/ | grep -q '301\\|302'; then
              echo '‚úÖ Redirecionamento HTTP ‚Üí HTTPS configurado'
            else
              echo 'üìù Site respondendo em HTTP (SSL pode n√£o estar configurado ainda)'
            fi
          else
            echo '‚ö†Ô∏è Dom√≠nio ${{ env.DOMAIN }} n√£o est√° respondendo via HTTP'
          fi
          
          # Testar HTTPS se dispon√≠vel
          if curl -f -s -k https://${{ env.DOMAIN }}/ >/dev/null 2>&1; then
            echo '‚úÖ Site HTTPS respondendo em https://${{ env.DOMAIN }}'
          else
            echo 'üìù HTTPS n√£o dispon√≠vel (SSL pode n√£o estar configurado)'
          fi
          
          # Testar www se dispon√≠vel
          if curl -f -s -k https://www.${{ env.DOMAIN }}/ >/dev/null 2>&1; then
            echo '‚úÖ Site HTTPS respondendo em https://www.${{ env.DOMAIN }}'
          elif curl -f -s http://www.${{ env.DOMAIN }}/ >/dev/null 2>&1; then
            echo '‚úÖ Site HTTP respondendo em http://www.${{ env.DOMAIN }}'
          else
            echo 'üìù Subdom√≠nio www pode n√£o estar configurado'
          fi
          
        "

    - name: üìä Relat√≥rio do Deploy
      if: always()
      run: |
        echo "üìä RELAT√ìRIO DO DEPLOY DOCKER"
        echo "============================="
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          echo 'Tipo de Deploy: ${{ needs.analyze-changes.outputs.deploy_type }}'
          echo 'Restart Executado: ${{ needs.analyze-changes.outputs.needs_restart }}'
          echo 'Depend√™ncias Atualizadas: ${{ needs.analyze-changes.outputs.has_package_changes }}'
          echo ''
          
          echo '=== Status do Container ==='
          if docker ps | grep -q ${{ env.CONTAINER_NAME }}; then
            docker ps | grep ${{ env.CONTAINER_NAME }}
          else
            echo '‚ùå Container n√£o encontrado'
          fi
          
          echo ''
          echo '=== √öltimo Commit ==='
          cd ${{ env.APP_DIR }} && git log --oneline -1 2>/dev/null || echo 'Reposit√≥rio git n√£o inicializado (deploy via rsync)'
          
          echo ''
          echo 'üåê URLs de Acesso:'
          echo '  - Site Principal: https://${{ env.DOMAIN }}'
          echo '  - Site WWW: https://www.${{ env.DOMAIN }}'
          echo '  - Acesso Direto: http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}'
          echo '‚ö° Deploy Docker DigiUrban2 conclu√≠do!'
        "

    - name: üéâ Deploy Conclu√≠do
      run: |
        echo "üéâ DEPLOY DOCKER DIGIURBAN2 REALIZADO COM SUCESSO!"
        echo "‚ö° Tipo: ${{ needs.analyze-changes.outputs.deploy_type }}"
        echo "üê≥ Deploy isolado em container Docker com Nginx Reverse Proxy"
        echo "üîí SSL/HTTPS configurado com Let's Encrypt"
        echo ""
        echo "üåê URLs de Acesso:"
        echo "  - Site Principal: https://${{ env.DOMAIN }}"
        echo "  - Site WWW: https://www.${{ env.DOMAIN }}"
        echo "  - Acesso Direto VPS: http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}"
        echo ""
        echo "‚úÖ DigiUrban2 est√° online e funcionando!"